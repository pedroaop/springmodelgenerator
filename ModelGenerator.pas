unit ModelGenerator;

interface

uses
   SysUtils,
   Spring.Persistence.Mapping.CodeGenerator.Abstract,
   Spring.Persistence.Mapping.CodeGenerator,
   System.RegularExpressions;

type
   TModelGenerator = class(TDelphiUnitCodeGenerator)
   private
      FTableName: string;
      FUnitBuilder: TStringBuilder;
      procedure SetTableName(const Value: string);
      function GetBlockIndent: string;
   public
      constructor Create; override;
      destructor Destroy; override;
      function AddUnit(const unitName: string): TStringBuilder; override;
      function AddClassAttribute(const attributeText: string)
        : TStringBuilder; override;
      function AddPrivateField(const columnData: TColumnData)
        : TStringBuilder; override;
      function AddPublicProperty(const columnData: TColumnData)
        : TStringBuilder; override;
      function AddGettersAndSetters(const columnData: TColumnData)
        : TStringBuilder;
      function AddImplGettersAndSetters(const columnData: TColumnData)
        : TStringBuilder;
      function AddTypeAttribute(const attributeText: string)
        : TStringBuilder; override;
      function GenerateEntityInterface(const entityData : TEntityModelData;
          ATableAlias: string): string;
      function GenerateEntityImplementation(const entityData : TEntityModelData;
          ATableAlias: string): string;
      function GetColumnCamelCase(const columnData: TColumnData): string;
      property TableName: string read FTableName write SetTableName;
      function GetUnitNameSpace(const entityData: TEntityModelData): string;
      property BlockIndent: string read GetBlockIndent;
   end;

implementation

const
   UNIT_ATTRIBUTES = 'Spring.Persistence.Mapping.Attributes';
   UNIT_NULLABLES = 'Spring';
   UNIT_CONTAINER = 'Spring.container';

function TModelGenerator.AddClassAttribute(const attributeText: string)
  : TStringBuilder;
begin
   Result := FUnitBuilder.AppendLine.Append(BlockIndent).Append(BlockIndent)
     .Append(attributeText);
end;

function TModelGenerator.AddGettersAndSetters(const columnData: TColumnData)
  : TStringBuilder;
var
   ColumnName: string;
   ColumnType: string;
begin
   ColumnName := GetColumnCamelCase(columnData);
   ColumnType := GetColumnTypeName(columnData);
   Result := FUnitBuilder.AppendLine.Append(BlockIndent).Append(BlockIndent)
     .AppendFormat('function Get%s: %s;', [ColumnName, ColumnType])
     .AppendLine.Append(BlockIndent).Append(BlockIndent)
     .AppendFormat('procedure Set%s(const Value: %s);',
     [ColumnName, ColumnType]);

end;

function TModelGenerator.AddImplGettersAndSetters(const columnData: TColumnData)
  : TStringBuilder;
var
   ColumnName: string;
   ColumnType: string;
begin
   ColumnName := GetColumnCamelCase(columnData);
   ColumnType := GetColumnTypeName(columnData);
   Result := FUnitBuilder.AppendFormat('function T%s.Get%s: %s;',
     [TableName, ColumnName, ColumnType]).AppendLine.Append('begin')
     .AppendLine.Append(BlockIndent).AppendFormat('Result := F%s', [ColumnName])
     .Append(';').AppendLine.Append('end;').AppendLine.AppendLine.AppendFormat
     ('procedure T%s.Set%s(const Value: %s);', [TableName, ColumnName,
     ColumnType]).AppendLine.Append('begin').AppendLine.Append(BlockIndent)
     .AppendFormat('F%s := Value;', [ColumnName]).AppendLine.Append('end;')
     .AppendLine.AppendLine;
end;

function TModelGenerator.AddPrivateField(const columnData: TColumnData)
  : TStringBuilder;
var
   ColumnName: string;
   ColumnType: string;
begin

   ColumnName := GetColumnCamelCase(columnData);
   ColumnType := GetColumnTypeName(columnData);

   if columnData.IsAutogenerated then
      AddClassAttribute('[AutoGenerated]');

   AddClassAttribute(GetColumnAttributeText(columnData));

   Result := FUnitBuilder.AppendLine.Append(BlockIndent).Append(BlockIndent)
     .AppendFormat('F%s: %s;', [ColumnName, ColumnType]).AppendLine;
end;

function TModelGenerator.AddPublicProperty(const columnData: TColumnData)
  : TStringBuilder;
var
   ColumnName: string;
   ColumnType: string;
begin
   ColumnName := GetColumnCamelCase(columnData);
   ColumnType := GetColumnTypeName(columnData);
   Result := FUnitBuilder.AppendLine.Append(BlockIndent).Append(BlockIndent)
     .AppendFormat('property %s: %s read Get%s write Set%s;',
     [ColumnName, ColumnType, ColumnName, ColumnName]);
end;

function TModelGenerator.AddTypeAttribute(const attributeText: string)
  : TStringBuilder;
begin
   Result := FUnitBuilder.AppendLine.Append(BlockIndent).Append(attributeText);
end;

function TModelGenerator.AddUnit(const unitName: string): TStringBuilder;
begin
   Result := FUnitBuilder.Append(',').AppendLine.Append(BlockIndent)
     .Append(unitName);
end;

constructor TModelGenerator.Create;
begin
   inherited Create;
   FUnitBuilder := TStringBuilder.Create;
end;

destructor TModelGenerator.Destroy;
begin
   FUnitBuilder.Free;
   inherited Destroy;
end;

{ TModelGenerator }

function TModelGenerator.GenerateEntityInterface(const entityData
  : TEntityModelData; ATableAlias: string): string;
var
   columnData: TColumnData;
begin

   TableName := entityData.TableName;

   FUnitBuilder.Clear;

   FUnitBuilder.AppendFormat('unit %s;', [GetUnitNameSpace(entityData)])
     .AppendLine.AppendLine;

   FUnitBuilder.Append('interface').AppendLine.AppendLine;

   if UseNullableTypes then
      FUnitBuilder.Append('uses').AppendLine.Append(BlockIndent)
        .Append(UNIT_NULLABLES).Append(';');

   FUnitBuilder.AppendLine.AppendLine.Append('type')
     .AppendLine.Append(BlockIndent).Append('I').Append(TableName)
     .Append(' = interface');

   for columnData in entityData.Columns do
      AddGettersAndSetters(columnData);

   FUnitBuilder.AppendLine;

   for columnData in entityData.Columns do
      AddPublicProperty(columnData);

   FUnitBuilder.AppendLine.Append(BlockIndent).Append('end').Append(';');

   FUnitBuilder.AppendLine.AppendLine.Append('implementation').AppendLine;

   FUnitBuilder.Append('end').Append('.');

   Result := FUnitBuilder.ToString;
end;

function TModelGenerator.GenerateEntityImplementation(const entityData
  : TEntityModelData; ATableAlias: string): string;
var
   columnData: TColumnData;
begin

   TableName := entityData.TableName;

   FUnitBuilder.Clear;

   FUnitBuilder.AppendFormat('unit %s;', [GetUnitNameSpace(entityData)])
     .AppendLine.AppendLine;

   FUnitBuilder.Append('interface').AppendLine.AppendLine;

   FUnitBuilder.Append('uses').AppendLine.Append(BlockIndent)
     .Append(UNIT_CONTAINER);
   AddUnit(UNIT_ATTRIBUTES);
   if UseNullableTypes then
      AddUnit(UNIT_NULLABLES);
   FUnitBuilder.Append(';').AppendLine.AppendLine;

   FUnitBuilder.Append('type');

   AddTypeAttribute('[Entity]');
   AddTypeAttribute(Format('[Table(%s)]', [QuotedStr(UpperCase(TableName))]));

   FUnitBuilder.AppendLine.Append(BlockIndent)
     .AppendFormat('T%s = class (TInterfacedObject, I%s)', [TableName, TableName]);

   FUnitBuilder.AppendLine.Append(BlockIndent).Append('private');
   for columnData in entityData.Columns do
      AddPrivateField(columnData);

   FUnitBuilder.AppendLine.Append(BlockIndent).Append('public');
   for columnData in entityData.Columns do
      AddGettersAndSetters(columnData);

   FUnitBuilder.AppendLine;

   for columnData in entityData.Columns do
      AddPublicProperty(columnData);

   FUnitBuilder.AppendLine.Append(BlockIndent).Append('end').Append(';');

   FUnitBuilder.AppendLine.AppendLine.Append('implementation')
     .AppendLine.AppendLine.AppendFormat('{ T%s }', [TableName])
     .AppendLine.AppendLine;
   for columnData in entityData.Columns do
      AddImplGettersAndSetters(columnData);

   FUnitBuilder.Append('initialization').AppendLine.Append(BlockIndent)
     .AppendFormat('GlobalContainer.RegisterType<I%s, T%s>(%s);',
     [TableName, TableName, QuotedStr(TableName)]).AppendLine.AppendLine;

   FUnitBuilder.Append('end').Append('.');

   Result := FUnitBuilder.ToString;

end;

function TModelGenerator.GetBlockIndent: string;
begin
   Result := '   ';
end;

function TModelGenerator.GetColumnCamelCase(const columnData
  : TColumnData): string;
var
   Input: string;
   Pattern: string;
   Splits: TArray<string>;
   Split: string;
begin
   Input := TRegEx.Replace(columnData.ColumnName, (TableName + '?'), EmptyStr,
     [roIgnoreCase]);
   Pattern := '_';
   Result := EmptyStr;
   Splits := TRegEx.Split(Input, Pattern);
   for Split in Splits do
   begin

      Result := Result + UpperCase(Copy(Split, 1, 1)) +
        LowerCase(Copy(Split, 2, Length(Split)))
   end;

end;

function TModelGenerator.GetUnitNameSpace(const entityData
  : TEntityModelData): string;
begin
   Result := UnitPrefix + TableName;
end;

procedure TModelGenerator.SetTableName(const Value: string);
begin
   FTableName := UpperCase(Copy(Value, 1, 1)) +
     LowerCase(Copy(Value, 2, Length(Value)));
end;

end.
